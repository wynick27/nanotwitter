{"name":"Nanotwitter","tagline":"A twitter mimic using Sinatra + Ruby + Postgres","body":"## Introduction\r\n![](https://raw.githubusercontent.com/wynick27/nanotwitter/master/sreenshots/Screen%20Shot%202015-12-07%20at%2011.11.54%20PM.png)\r\nMain page\r\n\r\nNanotwitter is a group project for COSI105B at Brandeis. Our team name is Llama.\r\n\r\n[Nanotwitter URL](http://nanotwitter-llama.herokuapp.com )\r\n\r\n## Technology Description:\r\nRedis: Caching the data that is frequently used and reduce the response time for user actions\r\nPostgres: Database to store the data including the user information, tweets send out, fellowship, and some others.\r\nAJAX: Dynamically send request to server and get response without refreshing the page.\r\nBootstrap: Front-end framework to build the interface for the website.\r\nJquery: A javascript library to add logic block and function to the website.\r\nTypeahead.js: A JS bootstrap plugin dynamically show available options based on current input value while typing.\r\nTagsinput.js: A JS bootstrap plugin automatically generate a tag when press enter in an input.\r\nFormvalidation.js: A JS bootstrap plugin dynamically validate various form input.\r\nMoment.js: A handy JS plugin manipulate date variables.\r\nNew Relic: Monitoring the performance of nanoTwiter website\r\nLoader.io: Testing the scalability of nanoTwiter by checking the response time of automatic visiting the website\r\nRspec: Testing the functionality of the website and the methods to see if they can function as we expected.\r\n\r\n\r\n##Interesting Engineering:\r\nDuring the progress, we did our best to study real twitter’s behavior, and tried to implement the functionality that twitter has.\r\n\r\n**Back-end**:  The sinatra app is using single file style at first where every function is written in a single file and the model file is almost nothing in it. After most of the functionality are implemented, the file become too large and hard to locate a specific route, what’s worse is several routes called same function such as Tweet.create in different places, sometimes the tweets is not properly analyzed which caused bugs. So we refactored it into several routes files like test, restful api, main, tweets etc.  And all useful functions used are in the model and controllers and views do almost nothing related to logic now.   Since tweets is regularly sorted by time, so we added an index on create_time. And we also added index for username and displayname. When generating user timeline and homepage, we need to load every user that posted the tweet, so I eager load all users to prevent generating n queries. And for tweets, we parse all tweets and analyze for hashtags and mentions, it’s also escaped because sinatra don’t do escaping by default, so that user can insert any html or javascript in their tweets, causing the website vulnerable to XSS attacks.\r\n\r\n**Front-end**: We choose AJAX over simple submit button in the HTML form, because refresh pages destroys user experience, a normal user would not like to scroll down to the same place again. Also, just like twitter, we decided to make the anything relate to the private chat dialog happen inside a popup modal. And we found it a big challenge to turn # and @ into an operational semantic and then trigger a list of options until we found a package named typeahead provided by twitter, which can return a list of options in real time as the user typing.\r\n\r\n![](https://raw.githubusercontent.com/wynick27/nanotwitter/master/sreenshots/Screen%20Shot%202015-12-07%20at%2011.25.37%20PM.png)\r\nLogin page\r\n\r\nWe allow user to upload their avatars.\r\n![](https://raw.githubusercontent.com/wynick27/nanotwitter/master/sreenshots/Screen%20Shot%202015-12-07%20at%2011.26.26%20PM.png)\r\nSettings page\r\n\r\nWe also implemented a group chat system, which allows user send private messages to a group of people.\r\n![](https://raw.githubusercontent.com/wynick27/nanotwitter/master/sreenshots/Screen%20Shot%202015-12-07%20at%2011.19.55%20PM.png)\r\nGroup chat\r\n\r\nThe dialog is stored in a tree structure and is loaded dynamically.\r\nUser's can also favourite a specific tweet.\r\n![](https://raw.githubusercontent.com/wynick27/nanotwitter/master/sreenshots/Screen%20Shot%202015-12-07%20at%2011.18.34%20PM.png)\r\n\r\n**RestAPI**: We decided to try both ways the SODRR textbook described to organize the API:\r\n/api/v1/user/username/:username\r\n/api/v1/users?username=USERNAME\r\nSo, the API we have can support both and the user can search with either way they like.  The search function works now and multi-words is supported.\r\n\r\n**Testing**: Unit test is easy to test as single methods can be tested directly with the proper setup. We did follow the instructions about the Capybara to do the integrity test and found it’s a little bit more complicate than the minitest and rspec, but the result turns out to be very good. One big challenge we had was that if we apply AJAX to the buttons, then the Capybara won’t accept than because the default driver won’t support JS. We have to switch the driver to :webkit in order to test the AJAX.\r\n\r\nClientLibrary: Client Library is implemented in ruby and users can access the data in the database without directly query the API.\r\n\r\n\r\n##Result of scalability work, timings etc.\r\nWe’ve added counter cache in many places. Like followings count, followers count, tweets count and favourites count in the user table so that instead of doing 4 aggregation query when showing information, it just checks the cache in the table. And for each tweet, we added favourite and retweet counter cache to avoid doing aggregation query. \r\nIndices are added to attributes that are common in join or sort operations. Like create_time for tweets. User id for tweets and other places.\r\nWe also added a postgres special gin index for full text search on tweets, which uses english tokenizer so that morphology is also considered. And it also provides highlight functionality.\r\nRedis is also used but only in the main page when user is not logged in. Because taking user timeline into consideration results in very complicated cache updating strategy which is not worth doing for index is already added to required fields. And actually we found using redis is resulting worse latency because redis is stored in amazon aws for heroku and communication cost is high.\r\nAjax is used whenever possible to avoid having to refresh entire page, which is costly. In timeline and user page we only shows 50 tweets when user accessed that page and when user scrolled down, more tweets is dynamically loaded using ajax.\r\n\r\n\r\nTeam members: Yun Wei, Zhongqi Li, Zhenyu Han\r\n\r\nDate: 12/6/2015","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}